/*
 * Copyright (c) 2023 NVIDIA CORPORATION & AFFILIATES, ALL RIGHTS RESERVED.
 *
 * This software product is a proprietary product of NVIDIA CORPORATION &
 * AFFILIATES (the "Company") and all right, title, and interest in and to the
 * software product, including all associated intellectual property rights, are
 * and shall remain exclusively with the Company.
 *
 * This software product is governed by the End User License Agreement
 * provided with the software product.
 *
 */

/**
 * @defgroup DOCA_DPA_HOST DOCA DPA Host
 * DOCA DPA Host library. For more details please refer to the user guide on DOCA devzone.
 *
 * @ingroup DOCA_DPA
 *
 * @{
 */
#ifndef DOCA_DPA_H_
#define DOCA_DPA_H_

#include <stdint.h>
#include <stddef.h>
#include <stdarg.h>
#include <stdbool.h>
#include <doca_compat.h>
#include <doca_error.h>

#ifdef __cplusplus
extern "C" {
#endif

/**
 * @brief Forward declarations
 */
struct doca_devinfo;
struct doca_dev;
struct doca_sync_event;
struct doca_dpa;
struct doca_buf;
struct doca_dpa_hash_table;
struct doca_dpa_eu_affinity;
struct doca_dpa_thread;
struct doca_dpa_tg;
struct doca_dpa_completion;
struct doca_dpa_async_ops;
struct doca_dpa_notification_completion;

/**
 * @brief DPA completion Log max user data type definition
 *
 * Valid values are greater equal to 0 and less than (1 << DOCA_DPA_COMPLETION_LOG_MAX_USER_DATA)
 */
#define DOCA_DPA_COMPLETION_LOG_MAX_USER_DATA (24)

/**
 * @brief DOCA DPA device log levels, sorted by verbosity from high to low
 */
typedef enum doca_dpa_dev_log_level {
	DOCA_DPA_DEV_LOG_LEVEL_DISABLE = 10, /**< Disable log messages */
	DOCA_DPA_DEV_LOG_LEVEL_ERROR = 30,   /**< Error log level */
	DOCA_DPA_DEV_LOG_LEVEL_WARNING = 40, /**< Warning log level */
	DOCA_DPA_DEV_LOG_LEVEL_INFO = 50,    /**< Info log level */
	DOCA_DPA_DEV_LOG_LEVEL_DEBUG = 60,   /**< Debug log level */
} doca_dpa_dev_log_level_t;

/**
 * @brief DPA context handle type definition
 */
typedef uint64_t doca_dpa_dev_t;

/**
 * @brief DPA pointer type definition
 */
typedef uint64_t doca_dpa_dev_uintptr_t;

/**
 * @brief DPA hash table handle type definition
 */
typedef uint64_t doca_dpa_dev_hash_table_t;

/**
 * @brief DPA completion handle type definition
 */
typedef uint64_t doca_dpa_dev_completion_t;

/**
 * @brief DPA asynchronous ops handle type definition
 */
typedef uint64_t doca_dpa_dev_async_ops_t;

/**
 * @brief DPA notification completion handle type definition
 */
typedef uint64_t doca_dpa_dev_notification_completion_t;

/**
 * @brief Opaque representation of a DPA Application
 *
 * This is an opaque structure that encapsulates a DPA application.
 * Typically, the DOCA DPA Host application will obtain the value
 * of this structure by linking in the appropriate stub library that is generated by DPACC
 */
struct doca_dpa_app;

/**
 * @brief Generic function pointer type
 *
 * Kernel launches are made using a host function pointer that represents the device function.
 * The host function stub is provided by the associated DPA compiler.
 * The C language does not define conversion of a function pointer to an object pointer (such as void*).
 * Programmers can use this generic function pointer type to typecast to
 * and adhere to strict ISO C language requirements
 */
typedef void(doca_dpa_func_t)(void);

/**
 * @brief Get whether the DOCA device supports DPA
 *
 * @param[in] devinfo - the device to query
 *
 * @return
 * - DOCA_SUCCESS - in case of the DOCA device queried has DPA support
 * - DOCA_ERROR_INVALID_VALUE - received invalid input
 * - DOCA_ERROR_NOT_SUPPORTED - the device queried does not support DPA
 */
DOCA_EXPERIMENTAL
doca_error_t doca_dpa_cap_is_supported(const struct doca_devinfo *devinfo);

/**
 * @brief Create a DOCA DPA Context
 *
 * This function creates a DOCA DPA context given a DOCA device.
 * The context represents a program on the DPA that is referenced
 * by the host process that called the context creation API
 *
 * @param[in] dev - DOCA device
 * @param[out] dpa - created context
 *
 * @return
 * - DOCA_SUCCESS - in case of success
 * - DOCA_ERROR_INVALID_VALUE - received invalid input
 * - DOCA_ERROR_DRIVER - in case of error in a DOCA driver call
 * - DOCA_ERROR_NOT_SUPPORTED - the device does not support DPA
 * - DOCA_ERROR_NO_MEMORY - in case of failure in internal memory allocation
 */
DOCA_EXPERIMENTAL
doca_error_t doca_dpa_create(struct doca_dev *dev, struct doca_dpa **dpa);

/**
 * @brief Destroy a DOCA DPA context
 *
 * This function destroys DPA context created by doca_dpa_create()
 *
 * @param[in] dpa - Previously created DPA context
 *
 * @return
 * - DOCA_SUCCESS - in case of success
 * - DOCA_ERROR_INVALID_VALUE - received invalid input
 * - DOCA_ERROR_DRIVER - in case of error in a DOCA driver call
 * - DOCA_ERROR_IN_USE - in case the DPA context is still used by another DOCA context
 */
DOCA_EXPERIMENTAL
doca_error_t doca_dpa_destroy(struct doca_dpa *dpa);

/**
 * @brief Start a DPA context
 *
 * @param[in] dpa - DPA context
 *
 * @return
 * - DOCA_SUCCESS - in case of success
 * - DOCA_ERROR_INVALID_VALUE - received invalid input
 * - DOCA_ERROR_DRIVER - in case of error in a DOCA driver call
 * - DOCA_ERROR_NO_MEMORY - in case of failure in internal memory allocation
 */
DOCA_EXPERIMENTAL
doca_error_t doca_dpa_start(struct doca_dpa *dpa);

/**
 * @brief Stop a DPA context
 *
 * @param[in] dpa - DPA context
 *
 * @return
 * - DOCA_SUCCESS - in case of success
 * - DOCA_ERROR_INVALID_VALUE - received invalid input
 * - DOCA_ERROR_DRIVER - in case of error in a DOCA driver call
 * - DOCA_ERROR_IN_USE - in case of attached thread/completion/extended DPA context that is not destroyed
 */
DOCA_EXPERIMENTAL
doca_error_t doca_dpa_stop(struct doca_dpa *dpa);

/**
 * @brief Set program app for DPA context
 *
 * The program app represents a program on the DPA that is referenced
 * by the host process that called the context creation API.
 * Must be set before calling doca_dpa_start()
 *
 * @param[in] dpa - DPA context
 * @param[in] app - DPA application generated by DPACC
 *
 * @return
 * - DOCA_SUCCESS - in case of success
 * - DOCA_ERROR_INVALID_VALUE - received invalid input
 * - DOCA_ERROR_BAD_STATE - if DPA context is already started
 */
DOCA_EXPERIMENTAL
doca_error_t doca_dpa_set_app(struct doca_dpa *dpa, struct doca_dpa_app *app);

/**
 * @brief Get program app that was set for DPA context
 *
 * @param[in] dpa - DPA context
 * @param[out] app - DPA application set for DPA context
 *
 * @return
 * - DOCA_SUCCESS - in case of success
 * - DOCA_ERROR_INVALID_VALUE - received invalid input
 */
DOCA_EXPERIMENTAL
doca_error_t doca_dpa_get_app(struct doca_dpa *dpa, struct doca_dpa_app **app);

/**
 * @brief Get DPA application name
 *
 * The name of a DPA application is assigned using DPACC during the build phase.
 * Once an application has been formed, its name is embedded within it.
 * This function allows DOCA DPA’s host application to retrieve the name that was previously assigned.
 *
 * The app_name buffer is allocated by the caller along with setting app_name_len indicating the length that was
 * allocated. Upon return the app_name_len field is set to the actual length of the app_name
 *
 * @param[in] app - DPA application generated by DPACC
 * @param[out] app_name - application name
 * @param[out] app_name_len - app_name length. Output is actual number of bytes written
 *
 * @return
 * - DOCA_SUCCESS - in case of success
 * - DOCA_ERROR_INVALID_VALUE - received invalid input, or the buffer received is of insufficient length
 * - DOCA_ERROR_DRIVER - in case of error in a DOCA driver call
 */
DOCA_EXPERIMENTAL
doca_error_t doca_dpa_app_get_name(struct doca_dpa_app *app, char *app_name, uint32_t *app_name_len);

/**
 * @brief Set device logs verbosity level
 *
 * Log prints from the device will be printed to host with verbosity that is equal or lower than the set log level.
 * Must be set before calling doca_dpa_start()
 * @note Default value of DPA log level is DOCA_DPA_DEV_LOG_LEVEL_INFO
 *
 * @param[in] dpa - DPA context
 * @param[in] log_level - verbosity level for device logs
 *
 * @return
 * - DOCA_SUCCESS - in case of success
 * - DOCA_ERROR_INVALID_VALUE - received invalid input
 * - DOCA_ERROR_BAD_STATE - DPA context is already started
 * - DOCA_ERROR_NOT_PERMITTED - DPA context is an extended DPA context (was created using doca_dpa_device_extend() API)
 */
DOCA_EXPERIMENTAL
doca_error_t doca_dpa_set_log_level(struct doca_dpa *dpa, doca_dpa_dev_log_level_t log_level);

/**
 * @brief Get device logs verbosity level that was set for DPA context
 *
 * @param[in] dpa - DPA context
 * @param[out] log_level - verbosity level for device logs
 *
 * @return
 * - DOCA_SUCCESS - in case of success
 * - DOCA_ERROR_INVALID_VALUE - received invalid null input
 */
DOCA_EXPERIMENTAL
doca_error_t doca_dpa_get_log_level(struct doca_dpa *dpa, doca_dpa_dev_log_level_t *log_level);

/**
 * @brief Set log file path to write device logs into
 *
 * Must be set before calling doca_dpa_start()
 * @note if not set then stdout will be used by default
 *
 * @param[in] dpa - DPA context
 * @param[in] file_path - pathname to the log file to write device logs into
 *
 * @return
 * - DOCA_SUCCESS - in case of success
 * - DOCA_ERROR_INVALID_VALUE - received invalid null input
 * - DOCA_ERROR_BAD_STATE - DPA context is already started
 * - DOCA_ERROR_NO_MEMORY - memory allocation error
 * - DOCA_ERROR_OPERATING_SYSTEM - error occurred in opening the file
 */
DOCA_EXPERIMENTAL
doca_error_t doca_dpa_log_file_set_path(struct doca_dpa *dpa, const char *file_path);

/**
 * @brief Get log file path to write device logs into
 *
 * @param[in] dpa - DPA context
 * @param[out] file_path - pathname to the log file to write device logs into
 * @param[out] file_path_len - file_path length. Output is actual number of bytes written
 *
 * The file_path buffer is allocated by the caller along with setting file_path_len indicating the length that was
 * allocated. Upon return the file_path_len field is set to the actual length of the file_path
 *
 * @return
 * - DOCA_SUCCESS - in case of success
 * - DOCA_ERROR_INVALID_VALUE - received invalid null input
 * - DOCA_ERROR_NO_MEMORY - memory allocation error
 */
DOCA_EXPERIMENTAL
doca_error_t doca_dpa_log_file_get_path(struct doca_dpa *dpa, char *file_path, uint32_t *file_path_len);

/**
 * @brief Set trace file path to write device traces into
 *
 * Must be set before calling doca_dpa_start()
 * @note if not set then stdout will be used by default
 *
 * @param[in] dpa - DPA context
 * @param[in] file_path - pathname to the trace file to write device traces into
 *
 * @return
 * - DOCA_SUCCESS - in case of success
 * - DOCA_ERROR_INVALID_VALUE - received invalid null input
 * - DOCA_ERROR_BAD_STATE - DPA context is already started
 * - DOCA_ERROR_NO_MEMORY - memory allocation error
 * - DOCA_ERROR_OPERATING_SYSTEM - error occurred in opening the file
 */
DOCA_EXPERIMENTAL
doca_error_t doca_dpa_trace_file_set_path(struct doca_dpa *dpa, const char *file_path);

/**
 * @brief Get trace file path to write device traces into
 *
 * @param[in] dpa - DPA context
 * @param[out] file_path - pathname to the trace file to write device traces into
 * @param[out] file_path_len - file_path length. Output is actual number of bytes written
 *
 * The file_path buffer is allocated by the caller along with setting file_path_len indicating the length that was
 * allocated. Upon return the file_path_len field is set to the actual length of the file_path
 *
 * @return
 * - DOCA_SUCCESS - in case of success
 * - DOCA_ERROR_INVALID_VALUE - received invalid null input
 * - DOCA_ERROR_NO_MEMORY - memory allocation error
 */
DOCA_EXPERIMENTAL
doca_error_t doca_dpa_trace_file_get_path(struct doca_dpa *dpa, char *file_path, uint32_t *file_path_len);

/**
 * @brief Get maximum number of DPA threads to run a single kernel launch operation
 *
 * @param[in] dpa - DPA context
 * @param[out] value - number of maximum threads to run a kernel
 *
 * @return
 * - DOCA_SUCCESS - in case of success
 * - DOCA_ERROR_INVALID_VALUE - received invalid NULL input
 */
DOCA_EXPERIMENTAL
doca_error_t doca_dpa_get_max_threads_per_kernel(const struct doca_dpa *dpa, unsigned int *value);

/**
 * @brief Get maximum allowable time in seconds that a kernel may remain scheduled on the DPA.
 * A kernel that remains scheduled beyond this limit may be terminated by the runtime and cause fatal behavior
 *
 * @param[in] dpa - DPA context
 * @param[out] value - maximum allowed time in seconds for a kernel to remain scheduled
 *
 * @return
 * - DOCA_SUCCESS - in case of success
 * - DOCA_ERROR_INVALID_VALUE - received invalid NULL input
 */
DOCA_EXPERIMENTAL
doca_error_t doca_dpa_get_kernel_max_run_time(const struct doca_dpa *dpa, unsigned long long *value);

/**
 * @brief Create an extended DPA context
 *
 * This function extends a base DPA context (was created on PF DOCA device) to other DOCA device (VF/SF device)
 * and creates an extended DPA context.
 * This to allow creation of DPA resources such as RDMA/DPA completion/DPA Async ops... contexts on the other device.
 * The extended DPA context can be used later on for all DOCA DPA APIs
 * such as creating DPA memory/DPA completion context/...
 * Please note:
 * - The returned DPA context will be already started.
 * - After creating the extended DPA context, user must destroy it before destroying the base DPA context.
 *
 * @param[in] dpa - Base DPA context
 * @param[in] other_dev - DOCA device to be extend to.
 * @param[out] extended_dpa - Created extended DPA context
 *
 * @return
 * - DOCA_SUCCESS - in case of success
 * - DOCA_ERROR_INVALID_VALUE - received invalid input
 * - DOCA_ERROR_BAD_STATE
 * 	- DPA context is not started
 * 	- DPA context is an extended DPA context
 * - DOCA_ERROR_NO_MEMORY - in case of failure in internal memory allocation
 * - DOCA_ERROR_DRIVER - in case of error in a DOCA driver call
 */
DOCA_EXPERIMENTAL
doca_error_t doca_dpa_device_extend(struct doca_dpa *dpa, struct doca_dev *other_dev, struct doca_dpa **extended_dpa);

/**
 * @brief Get DPA context handle
 *
 * @param[in] dpa - DPA context
 * @param[out] handle - DPA context handle
 *
 * @return
 * - DOCA_SUCCESS - in case of success
 * - DOCA_ERROR_INVALID_VALUE - received invalid input
 * - DOCA_ERROR_BAD_STATE - DPA completion is not started
 */
DOCA_EXPERIMENTAL
doca_error_t doca_dpa_get_dpa_handle(struct doca_dpa *dpa, doca_dpa_dev_t *handle);

/**
 * @brief Submit a kernel to DPA that sets completion event
 *
 * This function submits a kernel for launch on the specified `dpa` context.
 * The kernel starts execution when its wait event value is greater than
 * or equal to specified threshold. The completion event is set to value
 * specified in `comp_count` when the kernel finishes execution.
 *
 * The function to be launched `func` is a host function
 * pointer corresponding to the DPA device function.
 * For example, if the device function is declared as: `__dpa_global__ hello(int arg1)`,
 * then the user is expected to declare the function in the Host application
 * as `extern doca_dpa_func_t hello;`. After the application is linked and loaded
 * using the compiler, a function pointer `hello` can be used in as the `func` argument.
 * The arguments to the function `hello` can be passed inline in the call as var args.
 * For example, to call `hello` on the device using `4` threads with argument `5`,
 * the invocation looks like: `doca_dpa_kernel_launch_update_set(..., 4, hello, 5);`
 *
 * @param[in] dpa - previously created DPA context
 * @param[in] wait_event - event to wait on before executing the kernel (optional)
 * @param[in] wait_threshold - wait event count threshold to wait for before executing. Valid values [0-254]
 * @param[in] comp_event - event to signal after kernel execution is complete (optional)
 * @param[in] comp_count - completion count to set for completion event when func is complete
 * @param[in] num_threads - number of threads to use. This number must be equal or lower than the maximum allowed
 * (see doca_dpa_get_max_threads_per_kernel)
 * @param[in] func - host function pointer representing DPA kernel
 *
 * @return
 * - DOCA_SUCCESS - in case of success
 * - DOCA_ERROR_INVALID_VALUE - received invalid input
 * - DOCA_ERROR_DRIVER - in case of error in a DOCA driver call
 * - DOCA_ERROR_BAD_STATE - DPA context is not started
 */
DOCA_EXPERIMENTAL
doca_error_t doca_dpa_kernel_launch_update_set(struct doca_dpa *dpa,
					       struct doca_sync_event *wait_event,
					       uint64_t wait_threshold,
					       struct doca_sync_event *comp_event,
					       uint64_t comp_count,
					       unsigned int num_threads,
					       doca_dpa_func_t *func,
					       ... /* args */);

/**
 * @brief Submit a kernel to DPA
 *
 * This function submits a kernel for launch on the specified `dpa` context.
 * The kernel starts execution when its wait event value is greater than
 * or equal to specified threshold. The value specified in `comp_count`
 * is added to the `comp_event` when the kernel finishes execution.
 *
 * @param[in] dpa - previously created DPA context
 * @param[in] wait_event - event to wait on before executing the kernel (optional)
 * @param[in] wait_threshold - wait event count threshold to wait for before executing. Valid values [0-254]
 * @param[in] comp_event - event to signal after kernel execution is complete (optional)
 * @param[in] comp_count - completion count to add for completion event when func is complete
 * @param[in] num_threads - number of threads to use. This number must be equal or lower than the maximum allowed
 * (see doca_dpa_get_max_threads_per_kernel)
 * @param[in] func - host function pointer representing DPA kernel
 *
 * @return
 * - DOCA_SUCCESS - in case of success
 * - DOCA_ERROR_INVALID_VALUE - received invalid input
 * - DOCA_ERROR_DRIVER - in case of error in a DOCA driver call
 * - DOCA_ERROR_BAD_STATE - DPA context is not started
 */
DOCA_EXPERIMENTAL
doca_error_t doca_dpa_kernel_launch_update_add(struct doca_dpa *dpa,
					       struct doca_sync_event *wait_event,
					       uint64_t wait_threshold,
					       struct doca_sync_event *comp_event,
					       uint64_t comp_count,
					       unsigned int num_threads,
					       doca_dpa_func_t *func,
					       ... /* args */);

/**
 * @brief RPC to run DPA kernel
 *
 * This function executes the supplied `func` with its argument on the specified `dpa` context.
 * This is a blocking API.
 *
 * `func` is a host function pointer corresponding to the DPA device function.
 * Please note that DPA device `func` must be annotated with `__dpa_rpc__` annotation, such as
 * `__dpa_rpc__ uint64_t hello(int arg1)`.
 * Also the user is expected to declare the function in the Host application as
 * `extern doca_dpa_func_t hello;`.
 *
 * @param[in] dpa - DPA context
 * @param[in] func - Host function pointer representing DPA kernel to run
 * @param[out] retval - A pointer to the DPA kernel return value
 *
 * @return
 * - DOCA_SUCCESS - in case of success
 * - DOCA_ERROR_INVALID_VALUE - received invalid input
 * - DOCA_ERROR_DRIVER - error in a DOCA driver call
 * - DOCA_ERROR_BAD_STATE - attached DPA context is not started
 */
DOCA_EXPERIMENTAL
doca_error_t doca_dpa_rpc(struct doca_dpa *dpa, doca_dpa_func_t *func, uint64_t *retval, ... /* args */);

/**
 * @brief Return the last error generated on the DPA.
 * Check if an error occurred on the device side runtime. This call does not reset the error state.
 * If an error occurred, the DPA context enters a fatal state and must be destroyed by the user.
 * In the case of a fatal error core dump and crash data will be written to the file
 * path /tmp/doca_dpa_fatal or to the file path set by the API doca_dpa_log_file_set_path(),
 * with the suffixes .PID.core and .PID.crash respectively, where PID is the process id
 *
 * @param[in] dpa - DPA context
 *
 * @return
 * - DOCA_SUCCESS - in case of success
 * - DOCA_ERROR_INVALID_VALUE - received invalid NULL input
 * - DOCA_ERROR_BAD_STATE - received error on device side
 */
DOCA_EXPERIMENTAL
doca_error_t doca_dpa_peek_at_last_error(const struct doca_dpa *dpa);

/**
 * @brief Allocate DPA heap memory
 *
 * This function allocates memory of `size` bytes on the DPA process heap.
 * The memory is aligned for any language supported data type.
 * The memory is not zeroed on allocation. The allocated memory is returned in `dev_ptr` when successful.
 * When memory allocation fails, `dev_ptr` is set to 0x0 (NULL)
 *
 * @param[in] dpa - DPA context
 * @param[in] size - requested size of allocation
 * @param[out] dev_ptr - pointer to the allocated memory on the DPA device
 *
 * @return
 * - DOCA_SUCCESS - in case of success
 * - DOCA_ERROR_INVALID_VALUE - received invalid input
 * - DOCA_ERROR_DRIVER - in case of error in a DOCA driver call
 * - DOCA_ERROR_BAD_STATE - DPA context is not started
 */
DOCA_EXPERIMENTAL
doca_error_t doca_dpa_mem_alloc(struct doca_dpa *dpa, size_t size, doca_dpa_dev_uintptr_t *dev_ptr);

/**
 * @brief Free the previously allocated DPA memory
 *
 * This function frees the allocated memory allocated on the DPA heap. Users are expected to
 * ensure that kernels on the DPA are no longer accessing the memory
 * using established synchronization mechanisms (see events)
 *
 * @param[in] dpa - DPA context
 * @param[in] dev_ptr - pointer to the memory that was previously allocated on the DPA device
 *
 * @return
 * - DOCA_SUCCESS - in case of success
 * - DOCA_ERROR_DRIVER - in case of error in a DOCA driver call
 * - DOCA_ERROR_BAD_STATE - DPA context is not started
 */
DOCA_EXPERIMENTAL
doca_error_t doca_dpa_mem_free(struct doca_dpa *dpa, doca_dpa_dev_uintptr_t dev_ptr);

/**
 * @brief Copy from host memory to DPA Heap
 *
 * This function copies data from Host memory to the DPA heap. This is a blocking call.
 * When the call returns, the memory on the DPA is set to the values supplied in the Host buffer
 *
 * @param[in] dpa - DPA context
 * @param[in] dst_ptr - DPA device heap destination pointer
 * @param[in] src_ptr - host source buffer address
 * @param[in] size - size of data to copy
 *
 * @return
 * - DOCA_SUCCESS - in case of success
 * - DOCA_ERROR_INVALID_VALUE - received invalid input
 * - DOCA_ERROR_DRIVER - in case of error in a DOCA driver call
 * - DOCA_ERROR_BAD_STATE - DPA context is not started
 */
DOCA_EXPERIMENTAL
doca_error_t doca_dpa_h2d_memcpy(struct doca_dpa *dpa, doca_dpa_dev_uintptr_t dst_ptr, void *src_ptr, size_t size);

/**
 * @brief Copy from DOCA Buf to DPA Heap
 *
 * This function copies data from start of DOCA Buf to the DPA heap. This is a blocking call.
 * When the call returns, the memory on the DPA is set to the values supplied in the DOCA Buf
 *
 * @param[in] dpa - DPA context
 * @param[in] dst_ptr - DPA device heap destination pointer
 * @param[in] buf - source DOCA Buf
 * @param[in] size - size of data to copy
 *
 * @return
 * - DOCA_SUCCESS - in case of success
 * - DOCA_ERROR_INVALID_VALUE - received invalid input
 * - DOCA_ERROR_DRIVER - in case of error in a DOCA driver call
 * - DOCA_ERROR_BAD_STATE - DPA context is not started
 */
DOCA_EXPERIMENTAL
doca_error_t doca_dpa_h2d_buf_memcpy(struct doca_dpa *dpa,
				     doca_dpa_dev_uintptr_t dst_ptr,
				     struct doca_buf *buf,
				     size_t size);

/**
 * @brief Copy from DPA Heap to host memory
 *
 * This function copies data from the DPA heap to Host memory. This is a blocking call.
 * When the call returns, the memory on the Host buffer is set to the values supplied in the DPA heap pointer
 *
 * @param[in] dpa - DPA context
 * @param[in] dst_ptr - host destination buffer address
 * @param[in] src_ptr - DPA device heap source pointer
 * @param[in] size - size of data to copy
 *
 * @return
 * - DOCA_SUCCESS - in case of success
 * - DOCA_ERROR_INVALID_VALUE - received invalid input
 * - DOCA_ERROR_DRIVER - in case of error in a DOCA driver call
 * - DOCA_ERROR_BAD_STATE - DPA context is not started
 */
DOCA_EXPERIMENTAL
doca_error_t doca_dpa_d2h_memcpy(struct doca_dpa *dpa, void *dst_ptr, doca_dpa_dev_uintptr_t src_ptr, size_t size);

/**
 * @brief Copy from DPA Heap to DOCA Buf
 *
 * This function copies data from the DPA heap to start of DOCA Buf. This is a blocking call.
 * When the call returns, the memory on the DOCA Buf is set to the values supplied in the DPA heap pointer
 *
 * @param[in] dpa - DPA context
 * @param[in] buf - destination DOCA Buf
 * @param[in] src_ptr - DPA device heap source pointer
 * @param[in] size - size of data to copy
 *
 * @return
 * - DOCA_SUCCESS - in case of success
 * - DOCA_ERROR_INVALID_VALUE - received invalid input
 * - DOCA_ERROR_DRIVER - in case of error in a DOCA driver call
 * - DOCA_ERROR_BAD_STATE - DPA context is not started
 */
DOCA_EXPERIMENTAL
doca_error_t doca_dpa_d2h_buf_memcpy(struct doca_dpa *dpa,
				     struct doca_buf *buf,
				     doca_dpa_dev_uintptr_t src_ptr,
				     size_t size);

/**
 * @brief Set DPA Heap memory to a value
 *
 * This function sets DPA heap memory to a supplied value. This is a blocking call.
 * When the call returns, the memory on the DPA is set to the value supplied
 *
 * @param[in] dpa - DPA context
 * @param[in] dev_ptr - DPA device heap pointer
 * @param[in] value - value to set
 * @param[in] size - size of device buffer
 *
 * @return
 * - DOCA_SUCCESS - in case of success
 * - DOCA_ERROR_INVALID_VALUE - received invalid input
 * - DOCA_ERROR_DRIVER - in case of error in a DOCA driver call
 * - DOCA_ERROR_BAD_STATE - DPA context is not started
 */
DOCA_EXPERIMENTAL
doca_error_t doca_dpa_memset(struct doca_dpa *dpa, doca_dpa_dev_uintptr_t dev_ptr, int value, size_t size);

/**
 * @brief Create a hash table on DPA
 *
 * This function creates a hash table on DPA.
 * Once it is created, user can retrieve its DPA handle and use it for add, remove and find operations in DPA kernels
 *
 * @note Table size will be rounded to the next power of 2
 *
 * @param[in] dpa - DPA context
 * @param[in] num_entries - number of entries in the hash table
 * @param[out] ht - Created DPA hash table
 *
 * @return
 * - DOCA_SUCCESS - in case of success
 * - DOCA_ERROR_INVALID_VALUE - received invalid input
 * - DOCA_ERROR_DRIVER - in case of error in a DOCA driver call
 * - DOCA_ERROR_BAD_STATE - DPA context is not started
 */
DOCA_EXPERIMENTAL
doca_error_t doca_dpa_hash_table_create(struct doca_dpa *dpa,
					unsigned int num_entries,
					struct doca_dpa_hash_table **ht);

/**
 * @brief Destroy DPA hash table
 *
 * This function destroys DPA hash table created by doca_dpa_hash_table_create()
 *
 * @param[in] ht - Previously created DPA hash table
 *
 * @return
 * - DOCA_SUCCESS - in case of success
 * - DOCA_ERROR_INVALID_VALUE - received invalid input
 * - DOCA_ERROR_DRIVER - error in a DOCA driver call
 * - DOCA_ERROR_BAD_STATE
 * 	- attached DPA context is not started
 * 	- attached DPA context is destroyed
 */
DOCA_EXPERIMENTAL
doca_error_t doca_dpa_hash_table_destroy(struct doca_dpa_hash_table *ht);

/**
 * @brief Get DPA hash table handle
 *
 * @param[in] ht - DPA hash table
 * @param[out] ht_handle - DPA hash table handle
 *
 * @return
 * - DOCA_SUCCESS - in case of success
 * - DOCA_ERROR_INVALID_VALUE - received invalid input
 */
DOCA_EXPERIMENTAL
doca_error_t doca_dpa_hash_table_get_dpa_handle(struct doca_dpa_hash_table *ht, doca_dpa_dev_hash_table_t *ht_handle);

/**
 * @brief Retrieve the number of available DPA cores
 *
 * Use this info to select EU ID for DPA EU affinity
 *
 * @param[in] dpa - DPA context
 * @param[out] num_cores - number of DPA cores
 *
 * @return
 * - DOCA_SUCCESS - in case of success
 * - DOCA_ERROR_INVALID_VALUE - received invalid input
 */
DOCA_EXPERIMENTAL
doca_error_t doca_dpa_get_core_num(struct doca_dpa *dpa, unsigned int *num_cores);

/**
 * @brief Retrieve the number of EUs available per DPA core
 *
 * Use this info to select EU ID for DPA EU affinity
 *
 * @param[in] dpa - DPA context
 * @param[out] eus_per_core - number of EUs per DPA core
 *
 * @return
 * - DOCA_SUCCESS - in case of success
 * - DOCA_ERROR_INVALID_VALUE - received invalid input
 */
DOCA_EXPERIMENTAL
doca_error_t doca_dpa_get_num_eus_per_core(struct doca_dpa *dpa, unsigned int *eus_per_core);

/**
 * @brief Retrieve the total number of EUs available to the application
 *
 * Use this info to select EU ID for DPA EU affinity
 *
 * @param[in] dpa - DPA context
 * @param[out] total_num_eus - number of total available EUs
 *
 * @return
 * - DOCA_SUCCESS - in case of success
 * - DOCA_ERROR_INVALID_VALUE - received invalid input
 */
DOCA_EXPERIMENTAL
doca_error_t doca_dpa_get_total_num_eus_available(struct doca_dpa *dpa, unsigned int *total_num_eus);

/**
 * @brief Create DPA EU affinity.
 *
 * This function creates DPA EU affinity.
 * DPA EU affinity can be set for a DPA thread using doca_dpa_thread_set_affinity() to specify EU ID
 * which DPA thread will use on DPA.
 * Look at sched_getaffinity(3) for corresponding CPU use case. We are replicating it here for DPA
 *
 * @param[in] dpa - DPA context
 * @param[out] affinity - created DPA EU affinity
 *
 * @return
 * - DOCA_SUCCESS - in case of success
 * - DOCA_ERROR_INVALID_VALUE - received invalid input
 */
DOCA_EXPERIMENTAL
doca_error_t doca_dpa_eu_affinity_create(struct doca_dpa *dpa, struct doca_dpa_eu_affinity **affinity);

/**
 * @brief Destroy DPA EU affinity.
 *
 * This function destroys DPA EU affinity created by doca_dpa_eu_affinity_create()
 *
 * @param[in] affinity - previously created DPA EU affinity
 *
 * @return
 * - DOCA_SUCCESS - in case of success
 * - DOCA_ERROR_INVALID_VALUE - received invalid input
 * - DOCA_ERROR_BAD_STATE - attached DPA context is destroyed
 */
DOCA_EXPERIMENTAL
doca_error_t doca_dpa_eu_affinity_destroy(struct doca_dpa_eu_affinity *affinity);

/**
 * @brief Set EU ID in DPA EU affinity
 *
 * This function sets EU ID in the given DPA EU affinity
 *
 * @param[in] affinity - DPA EU affinity
 * @param[in] eu_id - EU ID
 *
 * @return
 * - DOCA_SUCCESS - in case of success
 * - DOCA_ERROR_INVALID_VALUE - received invalid input
 */
DOCA_EXPERIMENTAL
doca_error_t doca_dpa_eu_affinity_set(struct doca_dpa_eu_affinity *affinity, unsigned int eu_id);

/**
 * @brief Clear DPA EU affinity
 *
 * This function clears EU ID in the given DPA EU affinity
 *
 * @param[in] affinity - DPA EU affinity
 *
 * @return
 * - DOCA_SUCCESS - in case of success
 * - DOCA_ERROR_INVALID_VALUE - received invalid input
 */
DOCA_EXPERIMENTAL
doca_error_t doca_dpa_eu_affinity_clear(struct doca_dpa_eu_affinity *affinity);

/**
 * @brief Get EU ID from DPA EU affinity
 *
 * This function gets EU ID from the given DPA EU affinity
 *
 * @param[in] affinity - DPA EU affinity
 * @param[out] eu_id - EU ID
 *
 * @return
 * - DOCA_SUCCESS - in case of success
 * - DOCA_ERROR_INVALID_VALUE - received invalid input
 */
DOCA_EXPERIMENTAL
doca_error_t doca_dpa_eu_affinity_get(struct doca_dpa_eu_affinity *affinity, unsigned int *eu_id);

/**
 * @brief Create DPA thread
 *
 * This function creates a DPA thread.
 * DPA thread used to run a user kernel on DPA.
 * User can control on which EU to run the DPA kernel.
 * The thread is activated on DPA using two methods:
 * 1- Thread Activation using DPA notification completion context.
 * 2- Attaching completion context to the thread.
 * To activate the thread in order to enable receiving any messages or completions, user must:
 * 1- Create DPA thread and configure it using thread setter functions.
 * 2- Attach to a completion context.
 * 3- Set thread to runnable state using doca_dpa_thread_run() API.
 *
 * @param[in] dpa - DPA context
 * @param[out] dpa_thread - created DPA thread
 *
 * @return
 * - DOCA_SUCCESS - in case of success
 * - DOCA_ERROR_INVALID_VALUE - received invalid input
 * - DOCA_ERROR_NO_MEMORY - failure in internal memory allocation
 */
DOCA_EXPERIMENTAL
doca_error_t doca_dpa_thread_create(struct doca_dpa *dpa, struct doca_dpa_thread **dpa_thread);

/**
 * @brief Destroy DPA thread
 *
 * This function destroys DPA thread created by doca_dpa_thread_create()
 *
 * @param[in] dpa_thread - Previously created DPA thread
 *
 * @return
 * - DOCA_SUCCESS - in case of success
 * - DOCA_ERROR_INVALID_VALUE - received invalid input
 * - DOCA_ERROR_DRIVER - error in a DOCA driver call
 * - DOCA_ERROR_BAD_STATE - attached DPA context is destroyed
 */
DOCA_EXPERIMENTAL
doca_error_t doca_dpa_thread_destroy(struct doca_dpa_thread *dpa_thread);

/**
 * @brief Set DPA thread entry point and its argument
 *
 * The DPA thread function `func` is a host function pointer corresponding to the DPA device function.
 * The device function must be annotated with `__dpa_global__` keyword such as`__dpa_global__ void hello(int arg1)`.
 * In the Host application, the user is expected to declare the function as `extern doca_dpa_func_t hello;`.
 * After the application is linked and loaded using the compiler,
 * the function pointer `hello` can be used in as the `func` argument.
 * This function must be called before DPA thread is started
 *
 * @param[in] dpa_thread - DPA thread
 * @param[in] func - Host function pointer representing DPA kernel which thread run when it is triggered
 * @param[in] arg - DPA thread entry point argument
 *
 * @return
 * - DOCA_SUCCESS - in case of success
 * - DOCA_ERROR_INVALID_VALUE - received invalid input
 * - DOCA_ERROR_BAD_STATE - DPA thread is already started
 */
DOCA_EXPERIMENTAL
doca_error_t doca_dpa_thread_set_func_arg(struct doca_dpa_thread *dpa_thread, doca_dpa_func_t *func, uint64_t arg);

/**
 * @brief Get DPA thread entry point and its argument
 *
 * @param[in] dpa_thread - DPA thread
 * @param[out] func - DPA thread entry point
 * @param[out] arg - DPA thread entry point argument
 *
 * @return
 * - DOCA_SUCCESS - in case of success
 * - DOCA_ERROR_INVALID_VALUE - received invalid input
 */
DOCA_EXPERIMENTAL
doca_error_t doca_dpa_thread_get_func_arg(struct doca_dpa_thread *dpa_thread, doca_dpa_func_t **func, uint64_t *arg);

/**
 * @brief Set DPA thread local storage
 *
 * User can ask to store an opaque (DPA device memory pointer) for a DPA thread in host side using
 * Thread local storage utility.
 * In device kernel, user can obtain this opaque using doca_dpa_dev_thread_get_local_storage() API.
 * This function must be called before DPA thread is started
 *
 * @param[in] dpa_thread - DPA thread
 * @param[in] dev_ptr - DPA device memory address
 *
 * @return
 * - DOCA_SUCCESS - in case of success
 * - DOCA_ERROR_INVALID_VALUE - received invalid input
 * - DOCA_ERROR_BAD_STATE - DPA thread is already started
 */
DOCA_EXPERIMENTAL
doca_error_t doca_dpa_thread_set_local_storage(struct doca_dpa_thread *dpa_thread, doca_dpa_dev_uintptr_t dev_ptr);

/**
 * @brief Get DPA thread local storage
 *
 * @param[in] dpa_thread - DPA thread
 * @param[out] dev_ptr - DPA device memory address
 *
 * @return
 * - DOCA_SUCCESS - in case of success
 * - DOCA_ERROR_INVALID_VALUE - received invalid input
 */
DOCA_EXPERIMENTAL
doca_error_t doca_dpa_thread_get_local_storage(struct doca_dpa_thread *dpa_thread, doca_dpa_dev_uintptr_t *dev_ptr);

/**
 * @brief Set DPA thread affinity
 *
 * This function sets the affinity type of DPA thread to “fixed”.
 * Fixed affinity means that the thread will run only on the EU ID provided in the given DPA EU affinity.
 * When affinity is not specified, the default affinity mode is “relaxed”, means the thread will run on any available
 * EU ID when its rescheduled
 *
 * @param[in] dpa_thread - DPA thread
 * @param[in] affinity - DPA EU affinity
 *
 * @return
 * - DOCA_SUCCESS - in case of success
 * - DOCA_ERROR_INVALID_VALUE - received invalid input
 * - DOCA_ERROR_BAD_STATE - DPA thread is already started
 */
DOCA_EXPERIMENTAL
doca_error_t doca_dpa_thread_set_affinity(struct doca_dpa_thread *dpa_thread,
					  const struct doca_dpa_eu_affinity *affinity);

/**
 * @brief Get DPA thread affinity
 *
 * @param[in] dpa_thread - DPA thread
 * @param[out] affinity - DPA EU affinity
 *
 * @return
 * - DOCA_SUCCESS - in case of success
 * - DOCA_ERROR_INVALID_VALUE - received invalid input
 */
DOCA_EXPERIMENTAL
doca_error_t doca_dpa_thread_get_affinity(struct doca_dpa_thread *dpa_thread,
					  const struct doca_dpa_eu_affinity **affinity);

/**
 * @brief Start DPA thread
 *
 * @param[in] dpa_thread - DPA thread
 *
 * @return
 * - DOCA_SUCCESS - in case of success
 * - DOCA_ERROR_INVALID_VALUE - received invalid input
 * - DOCA_ERROR_DRIVER - error in a DOCA driver call
 * - DOCA_ERROR_BAD_STATE
 * 	- dpa thread func is not set (see doca_dpa_thread_set_func_arg())
 * 	- attached DPA context is not started
 * 	- attached DPA context is destroyed
 */
DOCA_EXPERIMENTAL
doca_error_t doca_dpa_thread_start(struct doca_dpa_thread *dpa_thread);

/**
 * @brief Stop DPA thread
 *
 * @param[in] dpa_thread - DPA thread
 *
 * @return
 * - DOCA_SUCCESS - in case of success
 * - DOCA_ERROR_INVALID_VALUE - received invalid input
 * - DOCA_ERROR_DRIVER - error in a DOCA driver call
 * - DOCA_ERROR_BAD_STATE - attached DPA context is destroyed
 */
DOCA_EXPERIMENTAL
doca_error_t doca_dpa_thread_stop(struct doca_dpa_thread *dpa_thread);

/**
 * @brief Run DPA thread
 *
 * This function sets the thread to runnable state such that
 * when the completion context attached to the thread receives a message, the thread will run.
 * This function must be called after DPA thread is:
 * 1- Created and started.
 * 2- Attached to a completion context.
 *
 * @param[in] dpa_thread - DPA thread
 *
 * @return
 * - DOCA_SUCCESS - in case of success
 * - DOCA_ERROR_INVALID_VALUE - received invalid input
 * - DOCA_ERROR_DRIVER - error in a DOCA driver call
 * - DOCA_ERROR_BAD_STATE
 * 	- attached DPA context is not started
 * 	- attached DPA context is destroyed
 * 	- DPA thread is not started
 */
DOCA_EXPERIMENTAL
doca_error_t doca_dpa_thread_run(struct doca_dpa_thread *dpa_thread);

/**
 * @brief Create DPA thread group
 *
 * This function creates an empty thread group (no populated threads) of a given size.
 * User can set thread at specific rank using doca_dpa_thread_group_set_thread() API.
 * Threads must be set in all ranks before thread group is started
 *
 * @param[in] dpa - DPA context
 * @param[in] num_threads - number of threads for the DPA thread group
 * @param[out] tg - created thread group
 *
 * @return
 * - DOCA_SUCCESS - in case of success
 * - DOCA_ERROR_INVALID_VALUE - received invalid input
 * - DOCA_ERROR_NO_MEMORY - failure in internal memory allocation
 */
DOCA_EXPERIMENTAL
doca_error_t doca_dpa_thread_group_create(struct doca_dpa *dpa, unsigned int num_threads, struct doca_dpa_tg **tg);

/**
 * @brief Destroy DPA thread group
 *
 * This function destroys DPA thread group created by doca_dpa_thread_group_create()
 *
 * @param[in] tg - Previously created DPA thread group
 *
 * @return
 * - DOCA_SUCCESS - in case of success
 * - DOCA_ERROR_INVALID_VALUE - received invalid input
 * - DOCA_ERROR_DRIVER - error in a DOCA driver call
 * - DOCA_ERROR_BAD_STATE - attached DPA context is destroyed
 */
DOCA_EXPERIMENTAL
doca_error_t doca_dpa_thread_group_destroy(struct doca_dpa_tg *tg);

/**
 * @brief Get DPA thread group number of threads
 *
 * @param[in] tg - DPA thread group
 * @param[out] num_threads - number of threads for the DPA thread group
 *
 * @return
 * - DOCA_SUCCESS - in case of success
 * - DOCA_ERROR_INVALID_VALUE - received invalid input
 */
DOCA_EXPERIMENTAL
doca_error_t doca_dpa_thread_group_get_num_threads(struct doca_dpa_tg *tg, unsigned int *num_threads);

/**
 * @brief Set DPA thread at 'rank' in DPA thread group
 *
 * Thread rank is an index of the thread (between 0 and size()-1) within the group.
 * This function must be called before starting both DPA thread and DPA thread group
 *
 * @param[in] tg - DPA thread group
 * @param[in] thread - DPA thread
 * @param[in] rank - rank of the DPA thread in DPA thread group
 *
 * @return
 * - DOCA_SUCCESS - in case of success
 * - DOCA_ERROR_INVALID_VALUE - received invalid input
 * - DOCA_ERROR_BAD_STATE
 * 	- attached DPA context is not started
 * 	- attached DPA context is destroyed
 * 	- DPA thread group is already started
 * 	- DPA thread is already started
 * 	- DPA thread is already attached to thread group
 */
DOCA_EXPERIMENTAL
doca_error_t doca_dpa_thread_group_set_thread(struct doca_dpa_tg *tg,
					      struct doca_dpa_thread *thread,
					      unsigned int rank);

/**
 * @brief Start DPA thread group
 *
 * @param[in] tg - DPA thread group
 *
 * @return
 * - DOCA_SUCCESS - in case of success
 * - DOCA_ERROR_INVALID_VALUE - received invalid input
 * - DOCA_ERROR_DRIVER - error in a DOCA driver call
 * - DOCA_ERROR_BAD_STATE
 * 	- attached DPA context is not started
 * 	- attached DPA context is destroyed
 * 	- one of the DPA threads in the group is not started/set
 */
DOCA_EXPERIMENTAL
doca_error_t doca_dpa_thread_group_start(struct doca_dpa_tg *tg);

/**
 * @brief Stop DPA thread group
 *
 * @param[in] tg - DPA thread group
 *
 * @return
 * - DOCA_SUCCESS - in case of success
 * - DOCA_ERROR_INVALID_VALUE - received invalid input
 * - DOCA_ERROR_DRIVER - error in a DOCA driver call
 * - DOCA_ERROR_BAD_STATE - attached DPA context is destroyed
 */
DOCA_EXPERIMENTAL
doca_error_t doca_dpa_thread_group_stop(struct doca_dpa_tg *tg);

/**
 * @brief Create DPA completion context
 *
 * This function creates a DPA completion context.
 * The user is responsible for creating and managing the context.
 * The completion context can raise activation if it is attached to a DPA thread.
 * The user can also decide to progress the context via polling it manually
 *
 * @note Queue size will be rounded to the next power of 2
 *
 * @param[in] dpa - DPA context
 * @param[in] queue_size - DPA completion queue size
 * @param[out] dpa_comp - created DPA completion
 *
 * @return
 * - DOCA_SUCCESS - in case of success
 * - DOCA_ERROR_INVALID_VALUE - received invalid input
 * - DOCA_ERROR_NO_MEMORY - failure in internal memory allocation
 */
DOCA_EXPERIMENTAL
doca_error_t doca_dpa_completion_create(struct doca_dpa *dpa,
					unsigned int queue_size,
					struct doca_dpa_completion **dpa_comp);

/**
 * @brief Destroy DPA completion context
 *
 * This function destroys DPA completion context created by doca_dpa_completion_create()
 *
 * @param[in] dpa_comp - Previously created DPA completion
 *
 * @return
 * - DOCA_SUCCESS - in case of success
 * - DOCA_ERROR_INVALID_VALUE - received invalid input
 * - DOCA_ERROR_DRIVER - error in a DOCA driver call
 * - DOCA_ERROR_BAD_STATE - attached DPA context is destroyed
 */
DOCA_EXPERIMENTAL
doca_error_t doca_dpa_completion_destroy(struct doca_dpa_completion *dpa_comp);

/**
 * @brief Get DPA completion context queue size
 *
 * @param[in] dpa_comp - DPA completion
 * @param[out] queue_size - DPA completion queue size
 *
 * @return
 * - DOCA_SUCCESS - in case of success
 * - DOCA_ERROR_INVALID_VALUE - received invalid input
 */
DOCA_EXPERIMENTAL
doca_error_t doca_dpa_completion_get_queue_size(struct doca_dpa_completion *dpa_comp, unsigned int *queue_size);

/**
 * @brief Set DPA completion context thread
 *
 * This function attaches DPA thread to DPA completion context.
 * Attaching to a DPA thread is required if the user wants activation of the thread when a completion is
 * raised on the completion context.
 * This function must be called before DPA completion is started
 *
 * @param[in] dpa_comp - DPA completion
 * @param[in] dpa_thread - DPA thread
 *
 * @return
 * - DOCA_SUCCESS - in case of success
 * - DOCA_ERROR_INVALID_VALUE - received invalid input
 * - DOCA_ERROR_BAD_STATE - DPA completion is already started
 */
DOCA_EXPERIMENTAL
doca_error_t doca_dpa_completion_set_thread(struct doca_dpa_completion *dpa_comp, struct doca_dpa_thread *dpa_thread);

/**
 * @brief Get DPA completion context attached thread
 *
 * @param[in] dpa_comp - DPA completion
 * @param[out] dpa_thread - DPA thread
 *
 * @return
 * - DOCA_SUCCESS - in case of success
 * - DOCA_ERROR_INVALID_VALUE - received invalid input
 */
DOCA_EXPERIMENTAL
doca_error_t doca_dpa_completion_get_thread(struct doca_dpa_completion *dpa_comp, struct doca_dpa_thread **dpa_thread);

/**
 * @brief Start DPA completion context
 *
 * @param[in] dpa_comp - DPA completion
 *
 * @return
 * - DOCA_SUCCESS - in case of success
 * - DOCA_ERROR_INVALID_VALUE - received invalid input
 * - DOCA_ERROR_DRIVER - error in a DOCA driver call
 * - DOCA_ERROR_BAD_STATE
 * 	- attached DPA context is not started
 * 	- attached DPA context is destroyed
 * 	- in case of thread is set but is not started
 */
DOCA_EXPERIMENTAL
doca_error_t doca_dpa_completion_start(struct doca_dpa_completion *dpa_comp);

/**
 * @brief Stop DPA completion context
 *
 * @param[in] dpa_comp - DPA completion
 *
 * @return
 * - DOCA_SUCCESS - in case of success
 * - DOCA_ERROR_INVALID_VALUE - received invalid input
 * - DOCA_ERROR_DRIVER - error in a DOCA driver call
 * - DOCA_ERROR_BAD_STATE - attached DPA context is destroyed
 */
DOCA_EXPERIMENTAL
doca_error_t doca_dpa_completion_stop(struct doca_dpa_completion *dpa_comp);

/**
 * @brief Get DPA completion context handle
 *
 * @param[in] dpa_comp - DPA completion
 * @param[out] handle - DPA completion handle
 *
 * @return
 * - DOCA_SUCCESS - in case of success
 * - DOCA_ERROR_INVALID_VALUE - received invalid input
 * - DOCA_ERROR_BAD_STATE - DPA completion is not started
 */
DOCA_EXPERIMENTAL
doca_error_t doca_dpa_completion_get_dpa_handle(struct doca_dpa_completion *dpa_comp,
						doca_dpa_dev_completion_t *handle);

/**
 * @brief Create DPA asynchronous ops context
 *
 * This function creates a DPA asynchronous ops context.
 * This allows the DPA thread to issue asynchronous operations, like DMA or other operations.
 * User can provide DPA asynchronous ops context `user_data`, and retrieve this metadata in device using
 * doca_dpa_dev_get_completion_user_data() API
 *
 * @note Queue size will be rounded to the next power of 2
 *
 * @param[in] dpa - DPA context
 * @param[in] queue_size - DPA asynchronous ops queue size
 * @param[in] user_data - DPA asynchronous ops user data
 * @param[out] async_ops - created DPA asynchronous ops
 *
 * @return
 * - DOCA_SUCCESS - in case of success
 * - DOCA_ERROR_INVALID_VALUE - received invalid input
 * - DOCA_ERROR_NO_MEMORY - failure in internal memory allocation
 */
DOCA_EXPERIMENTAL
doca_error_t doca_dpa_async_ops_create(struct doca_dpa *dpa,
				       unsigned int queue_size,
				       uint64_t user_data,
				       struct doca_dpa_async_ops **async_ops);

/**
 * @brief Destroy DPA asynchronous ops context
 *
 * This function destroys DPA asynchronous ops context created by doca_dpa_async_ops_create()
 *
 * @param[in] async_ops - Previously created DPA asynchronous ops
 *
 * @return
 * - DOCA_SUCCESS - in case of success
 * - DOCA_ERROR_INVALID_VALUE - received invalid input
 * - DOCA_ERROR_DRIVER - error in a DOCA driver call
 * - DOCA_ERROR_BAD_STATE - attached DPA context is destroyed
 */
DOCA_EXPERIMENTAL
doca_error_t doca_dpa_async_ops_destroy(struct doca_dpa_async_ops *async_ops);

/**
 * @brief Get DPA asynchronous ops queue size
 *
 * @param[in] async_ops - DPA asynchronous ops
 * @param[out] queue_size - DPA asynchronous ops queue size
 *
 * @return
 * - DOCA_SUCCESS - in case of success
 * - DOCA_ERROR_INVALID_VALUE - received invalid input
 */
DOCA_EXPERIMENTAL
doca_error_t doca_dpa_async_ops_get_queue_size(struct doca_dpa_async_ops *async_ops, unsigned int *queue_size);

/**
 * @brief Get DPA asynchronous ops context user data
 *
 * @param[in] async_ops - DPA asynchronous ops
 * @param[out] user_data - DPA asynchronous ops user data
 *
 * @return
 * - DOCA_SUCCESS - in case of success
 * - DOCA_ERROR_INVALID_VALUE - received invalid input
 */
DOCA_EXPERIMENTAL
doca_error_t doca_dpa_async_ops_get_user_data(struct doca_dpa_async_ops *async_ops, uint64_t *user_data);

/**
 * @brief Attach DPA asynchronous ops context to DPA completion context
 *
 * This function attaches DPA asynchronous ops context to DPA completion context.
 * Once a context is attached and both contexts are started, asynchronous operations completion will be raised
 * on the DPA completion (in case the user asks for a completion when issuing the operation).
 * This function must be called before DPA asynchronous ops is started
 *
 * @param[in] async_ops - DPA asynchronous ops
 * @param[in] dpa_comp - DPA completion
 *
 * @return
 * - DOCA_SUCCESS - in case of success
 * - DOCA_ERROR_INVALID_VALUE - received invalid input
 * - DOCA_ERROR_BAD_STATE - DPA asynchronous ops is already started
 */
DOCA_EXPERIMENTAL
doca_error_t doca_dpa_async_ops_attach(struct doca_dpa_async_ops *async_ops, struct doca_dpa_completion *dpa_comp);

/**
 * @brief Start DPA asynchronous ops context
 *
 * @param[in] async_ops - DPA asynchronous ops
 *
 * @return
 * - DOCA_SUCCESS - in case of success
 * - DOCA_ERROR_INVALID_VALUE - received invalid input
 * - DOCA_ERROR_DRIVER - error in a DOCA driver call
 * - DOCA_ERROR_BAD_STATE
 * 	- attached DPA context is not started
 * 	- attached DPA context is destroyed
 * 	- attached DPA asynchronous ops completion is not started/set
 */
DOCA_EXPERIMENTAL
doca_error_t doca_dpa_async_ops_start(struct doca_dpa_async_ops *async_ops);

/**
 * @brief Stop DPA asynchronous ops context
 *
 * @param[in] async_ops - DPA asynchronous ops
 *
 * @return
 * - DOCA_SUCCESS - in case of success
 * - DOCA_ERROR_INVALID_VALUE - received invalid input
 * - DOCA_ERROR_DRIVER - error in a DOCA driver call
 * - DOCA_ERROR_BAD_STATE - attached DPA context is destroyed
 */
DOCA_EXPERIMENTAL
doca_error_t doca_dpa_async_ops_stop(struct doca_dpa_async_ops *async_ops);

/**
 * @brief Get DPA asynchronous ops context handle
 *
 * @param[in] async_ops - DPA asynchronous ops
 * @param[out] handle - DPA asynchronous ops handle
 *
 * @return
 * - DOCA_SUCCESS - in case of success
 * - DOCA_ERROR_INVALID_VALUE - received invalid input
 * - DOCA_ERROR_BAD_STATE - DPA asynchronous ops is not started
 */
DOCA_EXPERIMENTAL
doca_error_t doca_dpa_async_ops_get_dpa_handle(struct doca_dpa_async_ops *async_ops, doca_dpa_dev_async_ops_t *handle);

/**
 * @brief Create DPA notification completion context
 *
 * This function creates a DPA notification completion context.
 * This context is used to activate the attached DPA thread in device using doca_dpa_dev_thread_notify() API.
 * The thread activation is done without receiving a completion on the thread's attached completion context.
 * Therefore it is expected that the user of this method of thread activation
 * will pass the message in another fashion – such as shared memory
 *
 * @param[in] dpa - DPA context
 * @param[in] dpa_thread - attached DPA thread
 * @param[out] notify_comp - created DPA notification completion
 *
 * @return
 * - DOCA_SUCCESS - in case of success
 * - DOCA_ERROR_INVALID_VALUE - received invalid input
 * - DOCA_ERROR_NO_MEMORY - failure in internal memory allocation
 */
DOCA_EXPERIMENTAL
doca_error_t doca_dpa_notification_completion_create(struct doca_dpa *dpa,
						     struct doca_dpa_thread *dpa_thread,
						     struct doca_dpa_notification_completion **notify_comp);

/**
 * @brief Destroy DPA notification completion context
 *
 * This function destroys DPA notification completion context created by doca_dpa_notification_completion_create()
 *
 * @param[in] notify_comp - Previously created DPA notification completion
 *
 * @return
 * - DOCA_SUCCESS - in case of success
 * - DOCA_ERROR_INVALID_VALUE - received invalid input
 * - DOCA_ERROR_DRIVER - error in a DOCA driver call
 * - DOCA_ERROR_BAD_STATE - attached DPA context is destroyed
 */
DOCA_EXPERIMENTAL
doca_error_t doca_dpa_notification_completion_destroy(struct doca_dpa_notification_completion *notify_comp);

/**
 * @brief Get DPA notification completion context attached thread
 *
 * @param[in] notify_comp - DPA notification completion
 * @param[out] dpa_thread - DPA thread
 *
 * @return
 * - DOCA_SUCCESS - in case of success
 * - DOCA_ERROR_INVALID_VALUE - received invalid input
 */
DOCA_EXPERIMENTAL
doca_error_t doca_dpa_notification_completion_get_thread(struct doca_dpa_notification_completion *notify_comp,
							 struct doca_dpa_thread **dpa_thread);

/**
 * @brief Start DPA notification completion context
 *
 * @param[in] notify_comp - DPA notification completion
 *
 * @return
 * - DOCA_SUCCESS - in case of success
 * - DOCA_ERROR_INVALID_VALUE - received invalid input
 * - DOCA_ERROR_DRIVER - error in a DOCA driver call
 * - DOCA_ERROR_BAD_STATE
 * 	- attached DPA context is not started
 * 	- attached DPA context is destroyed
 * 	- attached DPA thread is not started
 */
DOCA_EXPERIMENTAL
doca_error_t doca_dpa_notification_completion_start(struct doca_dpa_notification_completion *notify_comp);

/**
 * @brief Stop DPA notification completion context
 *
 * @param[in] notify_comp - DPA notification completion
 *
 * @return
 * - DOCA_SUCCESS - in case of success
 * - DOCA_ERROR_INVALID_VALUE - received invalid input
 * - DOCA_ERROR_DRIVER - error in a DOCA driver call
 * - DOCA_ERROR_BAD_STATE - attached DPA context is destroyed
 */
DOCA_EXPERIMENTAL
doca_error_t doca_dpa_notification_completion_stop(struct doca_dpa_notification_completion *notify_comp);

/**
 * @brief Get DPA notification completion context handle
 *
 * @param[in] notify_comp - DPA notification completion
 * @param[out] handle - DPA notification completion handle
 *
 * @return
 * - DOCA_SUCCESS - in case of success
 * - DOCA_ERROR_INVALID_VALUE - received invalid input
 * - DOCA_ERROR_BAD_STATE - DPA notification completion is not started
 */
DOCA_EXPERIMENTAL
doca_error_t doca_dpa_notification_completion_get_dpa_handle(struct doca_dpa_notification_completion *notify_comp,
							     doca_dpa_dev_notification_completion_t *handle);

#ifdef __cplusplus
}
#endif

#endif /* DOCA_DPA_H_ */

/** @} */
