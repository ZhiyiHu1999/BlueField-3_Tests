/*
 * Copyright (c) 2023 NVIDIA CORPORATION & AFFILIATES, ALL RIGHTS RESERVED.
 *
 * This software product is a proprietary product of NVIDIA CORPORATION &
 * AFFILIATES (the "Company") and all right, title, and interest in and to the
 * software product, including all associated intellectual property rights, are
 * and shall remain exclusively with the Company.
 *
 * This software product is governed by the End User License Agreement
 * provided with the software product.
 *
 */

/**
 * @defgroup DOCA_PCC DOCA PCC
 * @defgroup DOCA_PCC_HOST DOCA PCC Host
 * @ingroup DOCA_PCC
 * DOCA PCC Host library. For more details please refer to the user guide on DOCA devzone.
 *
 * @{
 */
#ifndef DOCA_PCC_H_
#define DOCA_PCC_H_

#include <stdbool.h>
#include <doca_compat.h>
#include <doca_error.h>

#ifdef __cplusplus
extern "C" {
#endif

/**
 * @brief Forward declarations
 */
struct doca_devinfo;
struct doca_dev;
struct doca_pcc;

/**
 * \brief Opaque representation of a PCC Application
 *
 * This is an opaque structure that encapsulates a PCC application.
 * Typically, the DOCA PCC Host application will obtain the value
 * of this structure by linking in the appropriate stub library that is generated by DPACC
 */
struct doca_pcc_app;

/**
 * @brief Get whether the DOCA device supports PCC reaction point
 *
 * @param[in]  devinfo - The device to query
 *
 * @return
 * DOCA_SUCCESS - in case of the DOCA device queried has PCC reaction point support
 * Error code - in case of failure:
 * - DOCA_ERROR_INVALID_VALUE - received invalid input
 * - DOCA_ERROR_NOT_SUPPORTED - the device queried does not support PCC reaction point
 */
DOCA_STABLE
doca_error_t doca_devinfo_get_is_pcc_supported(const struct doca_devinfo *devinfo);

/**
 * @brief Get whether the DOCA device supports PCC notification point
 *
 * @param[in]  devinfo - The device to query
 *
 * @return
 * DOCA_SUCCESS - in case of the DOCA device queried has PCC notification point support
 * Error code - in case of failure:
 * - DOCA_ERROR_INVALID_VALUE - received invalid input
 * - DOCA_ERROR_NOT_SUPPORTED - the device queried does not support PCC notification point
 */
DOCA_EXPERIMENTAL
doca_error_t doca_pcc_np_cap_is_supported(const struct doca_devinfo *devinfo);

/**
 * @brief Create programmable CC Reaction Point context
 *
 * This function creates a DOCA PCC Reaction Point context to capture and route PCC events to the DPA.
 *
 * @param[in]  doca_dev - DOCA device
 * @param[out]  pcc - Created PCC context
 *
 * @return
 * DOCA_SUCCESS - in case of success
 * doca_error code - in case of failure:
 * - DOCA_ERROR_INVALID_VALUE - received invalid input
 * - DOCA_ERROR_DRIVER - in case of error in a DOCA driver call
 * - DOCA_ERROR_NOT_SUPPORTED - the device does not support PCC
 * - DOCA_ERROR_NO_MEMORY - in case of failure in internal memory allocation
 */
DOCA_STABLE
doca_error_t doca_pcc_create(struct doca_dev *doca_dev, struct doca_pcc **pcc);

/**
 * @brief Create programmable CC Notification Point context
 *
 * This function creates a DOCA PCC Notification Point context given a DOCA device
 *
 * @param[in]  doca_dev - DOCA device
 * @param[out]  pcc - Created PCC context
 *
 * @return
 * DOCA_SUCCESS - in case of success
 * doca_error code - in case of failure:
 * - DOCA_ERROR_INVALID_VALUE - received invalid input
 * - DOCA_ERROR_DRIVER - in case of error in a DOCA driver call
 * - DOCA_ERROR_NOT_SUPPORTED - the device does not support PCC
 * - DOCA_ERROR_NO_MEMORY - in case of failure in internal memory allocation
 */
DOCA_EXPERIMENTAL
doca_error_t doca_pcc_np_create(struct doca_dev *doca_dev, struct doca_pcc **pcc);

/**
 * \brief Destroy a DOCA PCC context
 *
 * This function destroys PCC context created by doca_pcc_create()
 * When the termination is started the process will stop handling PCC events.
 * Issuing a ^c during doca_pcc_wait(...) will also result in the application's termination.
 *
 * @param[in]  pcc - Previously created PCC context
 *
 * @return
 * DOCA_SUCCESS - in case of success
 * doca_error code - in case of failure:
 * - DOCA_ERROR_INVALID_VALUE - received invalid input
 * - DOCA_ERROR_DRIVER - in case of error in a DOCA driver call
 */
DOCA_STABLE
doca_error_t doca_pcc_destroy(struct doca_pcc *pcc);

/**
 * @brief Start a PCC context
 * Register the pcc process in the NIC hw.
 *
 * @param[in]  pcc - PCC context
 *
 * @return
 * DOCA_SUCCESS - in case of success
 * doca_error code - in case of failure:
 * - DOCA_ERROR_INVALID_VALUE - received invalid input
 * - DOCA_ERROR_DRIVER - in case of error in a DOCA driver call
 * - DOCA_ERROR_NO_MEMORY - in case of failure in internal memory allocation
 * - DOCA_ERROR_NOT_SUPPORTED - the device does not support the PCC role
 */
DOCA_STABLE
doca_error_t doca_pcc_start(struct doca_pcc *pcc);

/**
 * @brief Stop a PCC context
 *
 * @param[in]  pcc - PCC context
 *
 * @return
 * DOCA_SUCCESS - in case of success
 * doca_error code - in case of failure:
 * - DOCA_ERROR_INVALID_VALUE - received invalid input
 * - DOCA_ERROR_DRIVER - in case of error in a DOCA driver call
 */
DOCA_STABLE
doca_error_t doca_pcc_stop(struct doca_pcc *pcc);

/**
 * @brief Get a minimal required number of threads handling CC events
 *
 * @param[in]  pcc - PCC context
 * @param[in]  min_num_threads - minimal number of threads used by pcc
 *
 * @return
 * DOCA_SUCCESS - in case of success
 * Error code - in case of failure:
 * - DOCA_ERROR_INVALID_VALUE - received invalid input
 */
DOCA_STABLE
doca_error_t doca_pcc_get_min_num_threads(struct doca_pcc *pcc, uint32_t *min_num_threads);

/**
 * @brief Get a maximal allowed number of threads handling CC events
 *
 * @param[in]  pcc - PCC context
 * @param[in]  max_num_threads - maximal number of threads used by pcc
 *
 * @return
 * DOCA_SUCCESS - in case of success
 * Error code - in case of failure:
 * - DOCA_ERROR_INVALID_VALUE - received invalid input
 */
DOCA_STABLE
doca_error_t doca_pcc_get_max_num_threads(struct doca_pcc *pcc, uint32_t *max_num_threads);

/**
 * @brief Set program app for PCC context
 *
 * The context represents a program on the DPA that is referenced
 * by the host process that called the context creation API.
 * Must be set before calling doca_pcc_start()
 *
 * @param[in]  pcc - PCC context
 * @param[in]  app - PCC application generated by DPACC
 *
 * @return
 * DOCA_SUCCESS - in case of success
 * doca_error code - in case of failure:
 * - DOCA_ERROR_INVALID_VALUE - received invalid input
 * - DOCA_ERROR_BAD_STATE - PCC context is already started
 */
DOCA_STABLE
doca_error_t doca_pcc_set_app(struct doca_pcc *pcc, struct doca_pcc_app *app);

/**
 * @brief Get number of available probe format slots
 *
 * The NIC may support multiple probe formats in parallel.
 * This function returns the number of probe formats supported by the
 * device used to open the pcc context.
 *
 * The caller may set probe_format_slot values of 0 to num_probe_format_slots - 1
 * in the functions referring to this value.
 *
 * @param[in]  pcc - PCC context
 * @param[out] num_probe_format_slots - number of available probe format slots
 *
 */
DOCA_EXPERIMENTAL
doca_error_t doca_pcc_cap_get_num_probe_format_slots(struct doca_pcc *pcc, uint32_t *num_probe_format_slots);

/**
 * @brief Set CCMAD probe packet format for the pcc process
 *
 * For RP: Sets the packet type to send to CCMAD when an rtt probe is requested.
 * For NP: defines CCMAD packet type to identify and send to the NP device side code
 *
 * @note CCMAD is default value for PCC context probe packet format
 *
 * @param[in]  pcc - PCC context
 * @param[in] probe_format_slot - format slot to configure. @see doca_pcc_cap_get_num_probe_format_slots()
 *
 * @return
 * DOCA_SUCCESS - in case of success
 * doca_error code - in case of failure:
 * - DOCA_ERROR_INVALID_VALUE - received invalid input
 * - DOCA_ERROR_NOT_SUPPORTED - the device does not support setting probe packet format
 * - DOCA_ERROR_BAD_STATE - PCC context is already started
 */
DOCA_EXPERIMENTAL
doca_error_t doca_pcc_set_ccmad_probe_packet_format(struct doca_pcc *pcc, uint32_t probe_format_slot);

/**
 * @brief Set ifa1 probe packet format for the pcc process
 *
 * For RP: Sets the packet type to send to ifa1 when an rtt probe is requested.
 * For NP: defines ifa1 packet type to identify and send to the NP device side code
 *
 * @param[in]  pcc - PCC context
 * @param[in] probe_format_slot - format slot to configure. @see doca_pcc_cap_get_num_probe_format_slots()
 *
 * @return
 * DOCA_SUCCESS - in case of success
 * doca_error code - in case of failure:
 * - DOCA_ERROR_INVALID_VALUE - received invalid input
 * - DOCA_ERROR_NOT_SUPPORTED - the device does not support setting probe packet format
 * - DOCA_ERROR_BAD_STATE - PCC context is already started
 */
DOCA_EXPERIMENTAL
doca_error_t doca_pcc_set_ifa1_probe_packet_format(struct doca_pcc *pcc, uint32_t probe_format_slot);

/**
 * @brief Set ifa2 probe packet format for the pcc process
 *
 * For RP: Sets the packet type to send to ifa2 when an rtt probe is requested.
 * For NP: defines ifa2 packet type to identify and send to the NP device side code
 *
 * @param[in]  pcc - PCC context
 * @param[in] probe_format_slot - format slot to configure. @see doca_pcc_cap_get_num_probe_format_slots()
 *
 * @return
 * DOCA_SUCCESS - in case of success
 * doca_error code - in case of failure:
 * - DOCA_ERROR_INVALID_VALUE - received invalid input
 * - DOCA_ERROR_NOT_SUPPORTED - the device does not support setting probe packet format
 * - DOCA_ERROR_BAD_STATE - PCC context is already started
 */
DOCA_EXPERIMENTAL
doca_error_t doca_pcc_set_ifa2_probe_packet_format(struct doca_pcc *pcc, uint32_t probe_format_slot);

/**
 * @brief Set sw remote handler for CCMAD probe type
 *
 * When a CCMAD probe packet is received by the remote RX NP port, it can be sent either
 * to the HW CC handler (for rtt probes) or to NP process for any probe format.
 *
 * @param[in] pcc - PCC context
 * @param[in] probe_format_slot - format slot to configure. @see doca_pcc_cap_get_num_probe_format_slots()
 * @param[in] sw_handler - When set, packets generated by the RP are handled by the NP PCC process.
 *                         When cleared, packets generated by the RP are handled by the NP HW handler
 *
 * @return
 * DOCA_SUCCESS - in case of success
 * doca_error code - in case of failure:
 * - DOCA_ERROR_INVALID_VALUE - received invalid input
 * - DOCA_ERROR_BAD_STATE - PCC context is already started
 */
DOCA_EXPERIMENTAL
doca_error_t doca_pcc_rp_set_ccmad_remote_sw_handler(struct doca_pcc *pcc, uint32_t probe_format_slot, bool sw_handler);

/**
 * @brief Get whether the DOCA device supports PCC ccmad customized header in reaction point
 *
 * @param[in]  devinfo - The device to query
 *
 * @return
 * DOCA_SUCCESS - in case the DOCA device queried has support for CCMAD custom header
 * Error code - in case of failure:
 * - DOCA_ERROR_INVALID_VALUE - received invalid input
 * - DOCA_ERROR_NOT_SUPPORTED - the device queried does not support CCMAD custom header
 */

DOCA_EXPERIMENTAL
doca_error_t doca_pcc_cap_is_ccmad_custom_header_supported(const struct doca_devinfo *devinfo);

/**
 * @brief Set customized header of CCMAD probe packet in RP
 *
 * Applicable to: RP role when probe packet format is set to ccmad
 *
 * Set the custom header size for CCMAD probe packet in RP.
 *
 * @param[in] pcc - PCC context
 * @param[in] probe_format_slot - format slot to configure. @see doca_pcc_cap_get_num_probe_format_slots()
 * @param[in] header_size - custom header size, unit is 4 Bytes
 *
 * @return
 * DOCA_SUCCESS - in case of success
 * doca_error code - in case of failure:
 * - DOCA_ERROR_INVALID_VALUE - received invalid input
 * - DOCA_ERROR_BAD_STATE - PCC context is already started
 */
DOCA_EXPERIMENTAL
doca_error_t doca_pcc_rp_set_ccmad_custom_header_size(struct doca_pcc *pcc,
						      uint32_t probe_format_slot,
						      uint8_t header_size);

/**
 *@brief CCMAD custom header location
 */
typedef enum {
	DOCA_PCC_CCMAD_CUSTOM_HEADER_LOCATION_MAD_PAYLOAD = 1, /**< Custom header will be inserted after MAD payload*/
} doca_pcc_ccmad_custom_header_loc_t;

/**
 * @brief Set customized header of CCMAD probe packet in RP
 *
 * Applicable to: RP role when probe packet format is set to ccmad
 *
 * Set the custom header location in CCMAD probe packet in RP.
 * 1: MAD_PAYLOAD - custom bytes inserted after the MAD payload
 *
 * @param[in] pcc - PCC context
 * @param[in] probe_format_slot - format slot to configure. @see doca_pcc_cap_get_num_probe_format_slots()
 * @param[in] header_loc - custom header location. @see doca_pcc_ccmad_custom_header_loc_t
 *
 * @return
 * DOCA_SUCCESS - in case of success
 * doca_error code - in case of failure:
 * - DOCA_ERROR_INVALID_VALUE - received invalid input
 * - DOCA_ERROR_BAD_STATE - PCC context is already started
 */
DOCA_EXPERIMENTAL
doca_error_t doca_pcc_rp_set_ccmad_custom_header_location(struct doca_pcc *pcc,
							  uint32_t probe_format_slot,
							  doca_pcc_ccmad_custom_header_loc_t header_loc);

/**
 * @brief Get whether the DOCA device supports PCC probe packet priority change in reaction point
 *
 * @param[in]  devinfo - The device to query
 *
 * @return
 * DOCA_SUCCESS - in case of the DOCA device queried has PCC probe packet priority change support
 * Error code - in case of failure:
 * - DOCA_ERROR_INVALID_VALUE - received invalid input
 * - DOCA_ERROR_NOT_SUPPORTED - the device queried does not support PCC probe packet priority change
 */
DOCA_EXPERIMENTAL
doca_error_t doca_pcc_cap_is_probe_priority_change_supported(const struct doca_devinfo *devinfo);

/**
 * @brief set enable flag to set CCMAD probe packet priority for PCC reaction point context
 *
 * @param[in]  pcc - PCC context
 * @param[in]  probe_format_slot - format slot to configure. @see doca_pcc_get_num_probe_format_slots
 * @param[in]  enable - enable CCMAD probe packet priority change if true; disable priority change if false
 *
 * @return
 * DOCA_SUCCESS - in case of success
 * doca_error code - in case of failure:
 * - DOCA_ERROR_INVALID_VALUE - received invalid input
 * - DOCA_ERROR_NOT_SUPPORTED - the device does not support setting probe packet format or change CCMAD probe packet
 * priority
 * - DOCA_ERROR_BAD_STATE - PCC context is already started
 */
DOCA_EXPERIMENTAL
doca_error_t doca_pcc_rp_set_ccmad_probe_priority_change_en(struct doca_pcc *pcc,
							    uint32_t probe_format_slot,
							    bool enable);

/**
 * @brief Set probe marker value for IFA1 probe
 *
 * Applicable to: RP/NP role when probe packet format is set to IFA1
 *
 * Set the probe marker field value in the generated IFA1 packets.
 * Note: the the most significant bit of the probe parameter must be set.
 *
 * By default the probe marker is set to 0xAAAAAAAABBBBBBBB
 *
 * @param[in] pcc - PCC context
 * @param[in] probe_format_slot - format slot to configure. @see doca_pcc_cap_get_num_probe_format_slots()
 * @param[in] probe_marker - probe marker value
 *
 * @return
 * DOCA_SUCCESS - in case of success
 * doca_error code - in case of failure:
 * - DOCA_ERROR_INVALID_VALUE - received invalid input
 * - DOCA_ERROR_NOT_SUPPORTED - the device does not support setting probe packet format
 * - DOCA_ERROR_BAD_STATE - PCC context is already started
 */
DOCA_EXPERIMENTAL
doca_error_t doca_pcc_set_ifa1_probe_marker(struct doca_pcc *pcc, uint32_t probe_format_slot, uint64_t probe_marker);

/**
 * @brief Set GNS value for IFA2 packets
 *
 * Applicable to: RP role when probe packet format is set to IFA2
 *
 * By default IFA2 gns value is set to 0xF
 *
 * @param[in] pcc - PCC context
 * @param[in] probe_format_slot - format slot to configure. @see doca_pcc_get_num_probe_format_slots
 * @param[in] gns - global namespace - limited to 4 bits
 *
 * @return
 * DOCA_SUCCESS - in case of success
 * doca_error code - in case of failure:
 * - DOCA_ERROR_INVALID_VALUE - received invalid input
 * - DOCA_ERROR_NOT_SUPPORTED - the device does not support setting probe packet format
 * - DOCA_ERROR_BAD_STATE - PCC context is already started
 */
DOCA_EXPERIMENTAL
doca_error_t doca_pcc_rp_set_ifa2_gns(struct doca_pcc *pcc, uint32_t probe_format_slot, uint8_t gns);

/**
 * @brief Set GNS ignore for IFA2 packets
 *
 * Applicable to: NP role when probe packet format is set to IFA2
 *
 * When (ignore_mask != 0), if:
 *   (packet.GNS & ignore_mask) == (ignore_value & ignore_mask)
 * the packet will not be sent to the NP process, and will be delivered to SW as a standard eth packet.
 *
 * By default all IFA2 packets are sent to the NP process (ignore_mask = 0)
 *
 * @param[in] pcc - PCC context
 * @param[in] probe_format_slot - format slot to configure. @see doca_pcc_cap_get_num_probe_format_slots()
 * @param[in] ignore_mask - GNS ignore mask - limited to 4 bits
 * @param[in] ignore_value - GNS ignore value - limited to 4 bits
 *
 * @return
 * DOCA_SUCCESS - in case of success
 * doca_error code - in case of failure:
 * - DOCA_ERROR_INVALID_VALUE - received invalid input
 * - DOCA_ERROR_NOT_SUPPORTED - the device does not support setting probe packet format
 * - DOCA_ERROR_BAD_STATE - PCC context is already started
 */
DOCA_EXPERIMENTAL
doca_error_t doca_pcc_np_set_ifa2_gns_ignore(struct doca_pcc *pcc,
					     uint32_t probe_format_slot,
					     uint8_t ignore_mask,
					     uint8_t ignore_value);

/**
 * @brief Set hop_limit field in the metadata header for IFA2 packets
 *
 * Applicable to: RP role when probe packet format is set to IFA2
 *
 * By default IFA2 hop_limit value is set to 0xFE
 *
 * @param[in] pcc - PCC context
 * @param[in] probe_format_slot - format slot to configure. @see doca_pcc_get_num_probe_format_slots
 * @param[in] hop_limit - hop limit value to set
 *
 * @return
 * DOCA_SUCCESS - in case of success
 * doca_error code - in case of failure:
 * - DOCA_ERROR_INVALID_VALUE - received invalid input
 * - DOCA_ERROR_NOT_SUPPORTED - the device does not support setting probe packet format
 * - DOCA_ERROR_BAD_STATE - PCC context is already started
 */
DOCA_EXPERIMENTAL
doca_error_t doca_pcc_rp_set_ifa2_hop_limit(struct doca_pcc *pcc, uint32_t probe_format_slot, uint8_t hop_limit);

/**
 * @brief Configure affinity of threads handling CC events
 *
 * Must be set before calling doca_pcc_start()
 *
 * @param[in]  pcc - PCC context
 * @param[in]  num_threads - number of threads used by pcc. Should be constrained by minimum and maximum allowed number
 * @see doca_pcc_get_min_num_threads() and doca_pcc_get_max_num_threads()
 * @param[in]  affinity_configs - array of indexes to assign to threads
 *
 * @return
 * DOCA_SUCCESS - in case of success
 * doca_error code - in case of failure:
 * - DOCA_ERROR_INVALID_VALUE - received invalid input or invalid number of threads
 * - DOCA_ERROR_BAD_STATE - PCC context is already started
 */
DOCA_STABLE
doca_error_t doca_pcc_set_thread_affinity(struct doca_pcc *pcc, uint32_t num_threads, uint32_t *affinity_configs);

/**
 * @brief Set message for trace printing
 *
 * Must be set before calling doca_pcc_start()
 *
 * @param[in]  pcc - PCC context
 * @param[in]  trace_message - message to be printed from trace
 *
 * @return
 * DOCA_SUCCESS - in case of success
 * doca_error code - in case of failure:
 * - DOCA_ERROR_INVALID_VALUE - received invalid input
 * - DOCA_ERROR_BAD_STATE - PCC context is already started
 * - DOCA_ERROR_NO_MEMORY - in case of failure in internal memory allocation
 */
DOCA_STABLE
doca_error_t doca_pcc_set_trace_message(struct doca_pcc *pcc, char **trace_message);

/**
 * @brief Set buffer size of DPA print message
 *
 * Must be set before calling doca_pcc_start()
 *
 * @param[in]  pcc - PCC context
 * @param[in]  buffer_size - size of print buffer from the DPA
 *
 * @return
 * DOCA_SUCCESS - in case of success
 * doca_error code - in case of failure:
 * - DOCA_ERROR_INVALID_VALUE - received invalid input
 * - DOCA_ERROR_BAD_STATE - PCC context is already started
 */
DOCA_STABLE
doca_error_t doca_pcc_set_print_buffer_size(struct doca_pcc *pcc, size_t buffer_size);

/**
 * @brief Set output file to write crash data and coredump in case of unrecoverable error on the device
 *
 * Must be set before calling doca_pcc_start()
 *
 * @param[in]  pcc - PCC context
 * @param[in]  file_name - pathname to the output file to write coredump data into
 *
 * @return
 * DOCA_SUCCESS - in case of success
 * doca_error code - in case of failure:
 * - DOCA_ERROR_INVALID_VALUE - received invalid input
 * - DOCA_ERROR_BAD_STATE - PCC context is already started
 * - DOCA_ERROR_NO_MEMORY - memory allocation error
 */
DOCA_STABLE
doca_error_t doca_pcc_set_dev_coredump_file(struct doca_pcc *pcc, const char *file_name);

/**
 * @brief Set mailbox attributes to obtain and pass data from and to the device
 *
 * Must be set before calling doca_pcc_start()
 *
 * @param[in]  pcc - PCC context
 * @param[in]  max_request_size - max size of request data passed to device
 * @param[in]  max_response_size - max size of response data passed from device
 *
 * @return
 * DOCA_SUCCESS - in case of success
 * doca_error code - in case of failure:
 * - DOCA_ERROR_INVALID_VALUE - received invalid input
 * - DOCA_ERROR_BAD_STATE - PCC context is already started
 */
DOCA_EXPERIMENTAL
doca_error_t doca_pcc_set_mailbox(struct doca_pcc *pcc, uint32_t max_request_size, uint32_t max_response_size);

/**
 * @brief Get mailbox request data buffer address to fill and transfer to device
 *
 * @param[in]  pcc - PCC context
 * @param[out]  request_buffer - pointer to request data buffer
 *
 * @return
 * DOCA_SUCCESS - in case of success
 * doca_error code - in case of failure:
 * - DOCA_ERROR_INVALID_VALUE - received invalid input
 * - DOCA_ERROR_BAD_STATE - in case pcc is not started
 * - DOCA_ERROR_INITIALIZATION - mailbox was not set for PCC context
 */
DOCA_EXPERIMENTAL
doca_error_t doca_pcc_mailbox_get_request_buffer(struct doca_pcc *pcc, void **request_buffer);

/**
 * @brief Get mailbox response data buffer address that contains data transferred from device
 *
 * @param[in]  pcc - PCC context
 * @param[out]  response_buffer - pointer to response data buffer
 *
 * @return
 * DOCA_SUCCESS - in case of success
 * doca_error code - in case of failure:
 * - DOCA_ERROR_INVALID_VALUE - received invalid input
 * - DOCA_ERROR_BAD_STATE - in case pcc is not started
 * - DOCA_ERROR_INITIALIZATION - mailbox was not set for PCC context
 */
DOCA_EXPERIMENTAL
doca_error_t doca_pcc_mailbox_get_response_buffer(struct doca_pcc *pcc, void **response_buffer);

/**
 * @brief Send mailbox request data to device
 *
 * @param[in]  pcc - PCC context
 * @param[in]  request_size - size of request data to send to device
 * @param[out]  response_size - size of response data received from device
 * @param[out]  cb_ret_val - return value of device user callback doca_pcc_dev_user_mailbox_handle()
 *
 * @return
 * DOCA_SUCCESS - in case of success
 * doca_error code - in case of failure:
 * - DOCA_ERROR_INVALID_VALUE - received invalid input
 * - DOCA_ERROR_DRIVER - in case of error in a DOCA driver call
 * - DOCA_ERROR_BAD_STATE - in case pcc is not started
 * - DOCA_ERROR_INITIALIZATION - mailbox was not set for PCC context
 */
DOCA_EXPERIMENTAL
doca_error_t doca_pcc_mailbox_send(struct doca_pcc *pcc,
				   uint32_t request_size,
				   uint32_t *response_size,
				   uint32_t *cb_ret_val);

/**
 * @brief Wait on events or timeout from device for given time in seconds.
 *
 * Providing a negative value for wait time will cause the context to wait on events until the user terminates it.
 *
 * @param[in]  pcc - PCC context
 * @param[in]  wait_time - time in seconds to wait
 *
 * @return
 * DOCA_SUCCESS - in case of success
 * doca_error code - in case of failure:
 * - DOCA_ERROR_INVALID_VALUE - received invalid input
 * - DOCA_ERROR_BAD_STATE - in case pcc is not started
 */
DOCA_STABLE
doca_error_t doca_pcc_wait(struct doca_pcc *pcc, int wait_time);

/**
 * @brief Process states
 */
typedef enum {
	DOCA_PCC_PS_ACTIVE = 0,	     /**< The process handles CC events (only one process is active at a given time) */
	DOCA_PCC_PS_STANDBY = 1,     /**< The process is in standby mode (another process is already ACTIVE)*/
	DOCA_PCC_PS_DEACTIVATED = 2, /**< The process was deactivated by NIC FW and should be destroyed */
	DOCA_PCC_PS_ERROR = 3,	     /**< The process is in error state and should be destroyed */
} doca_pcc_process_state_t;

/**
 * @brief Return the state of the process.
 *
 * @param[in]  pcc - PCC context
 * @param[out]  process_state - state of the PCC process. In case positive wait_time is specified and expired,
 * DEACTIVATED state will be returned.
 *
 * @return
 * DOCA_SUCCESS - in case of success
 * doca_error code - in case of failure:
 * - DOCA_ERROR_INVALID_VALUE - received invalid input
 * - DOCA_ERROR_BAD_STATE - in case pcc is not started
 */
DOCA_STABLE
doca_error_t doca_pcc_get_process_state(const struct doca_pcc *pcc, doca_pcc_process_state_t *process_state);

/**
 * @brief Dump device side debug info.
 *
 * Must call doca_pcc_enable_debug(pcc, true) to enable debug first;
 * Otherwise no debug info will be dumped.
 *
 * @param[in]  pcc - PCC context
 *
 * @return
 * DOCA_SUCCESS - in case of success
 * doca_error code - in case of failure:
 * - DOCA_ERROR_INVALID_VALUE - received invalid input
 * - DOCA_ERROR_BAD_STATE - in case pcc is not started
 * - DOCA_ERROR_DRIVER - in case of error in a DOCA driver call
 */
DOCA_EXPERIMENTAL
doca_error_t doca_pcc_dump_debug(const struct doca_pcc *pcc);

/**
 * @brief Enable or disable device side debug.
 *
 * When issues arize, device side debugging can be enabled during runtime.
 * Subsequently, calling doca_pcc_dump_debug(pcc) will output the debugging info.
 * This debug info can assist in pinpointing the source of the issues.
 * The same function can be used to disable device side debugging during runtime.
 *
 * @param[in]  pcc - PCC context
 * @param[in]  enable - enable debug if true; disable debug if false.
 *
 * @return
 * DOCA_SUCCESS - in case of success
 * doca_error code - in case of failure:
 * - DOCA_ERROR_INVALID_VALUE - received invalid input
 * - DOCA_ERROR_BAD_STATE - in case pcc is not started
 * - DOCA_ERROR_DRIVER - in case of error in a DOCA driver call
 */
DOCA_EXPERIMENTAL
doca_error_t doca_pcc_enable_debug(const struct doca_pcc *pcc, bool enable);

#ifdef __cplusplus
}
#endif

#endif /* DOCA_PCC_H_ */

/** @} */
